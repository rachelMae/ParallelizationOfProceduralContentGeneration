package com.pcg;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.HashMap;

import org.joml.Vector3f;

/** Marching Cubes Algorithm with Mulithreading */
// Each thread takes on a "chunk" of the voxel grid
// For example, if the voxel grid is 128x128x128 and there are 32 threads, each thread will take on 4 rows of the voxel grid. These look like slabs:

// Thread 1
//   +--------+
// /        / |
// +--------+ |
// |        |/
// +--------+
// Thread 2
//   +--------+
//  /        /|
// +--------+ |
// |        |/
// +--------+
// Thread 3
//   +--------+
//  /        /|
// +--------+ |
// |        |/
// +--------+
// Thread 4
//   +--------+
//  /        /|
// +--------+ |
// |        |/
// +--------+
// ... and so on

class GridProcessor extends VoxelGrid implements Runnable {
    private int row_index;
    private int num_rows_per_thread;
    // the vertices generated by this thread
    private ArrayList<Vector3f> positions = new ArrayList<Vector3f>();

    public GridProcessor(ArrayList<Float> voxel_grid, int resolution, int row_index, int num_rows_per_thread) {
        super(voxel_grid, resolution);
        this.row_index = row_index;
        this.num_rows_per_thread = num_rows_per_thread;
    }

    public void run()
    {
        try {
            // run marching cubes algorithm for designated slabs in voxel grid
            // a slab heighht is the num_rows_per_thread
            for (int z = this.row_index; z < this.row_index + num_rows_per_thread; z++) {
                if (z >= this.resolution - 1) {
                    break;
                }
                for (int y = 0; y < this.resolution - 1; y++) {
                    for (int x = 0; x < this.resolution - 1; x++) {
                        VoxelGrid.march_cube(x, y, z,
                            this,
                            this.positions,
                            (int)Thread.currentThread().getId()
                        );
                        // System.out.println("Thread " + Thread.currentThread().getId() + " is processing voxel at (" + x + ", " + y + ", " + z + ")");
                    }
                }
            }
        }
        catch (Exception e) {
            System.out.println(Thread.currentThread().getId()  + " Exception is caught: " + e);
        } finally {
            // System.out.println("Thread " + Thread.currentThread().getId() + " is done");
            System.out.println("Thread " + Thread.currentThread().getId() + " has " + this.positions.size() + " vertices");
        }
    }

    public ArrayList<Vector3f> get_positions() {
        return this.positions;
    }

    public int get_row_index() {
        return this.row_index;
    }
}

// Main Class
class MultithreadedVoxelGrid {
    private int resolution;
    private int num_rows_per_thread;
    private ArrayList<Float> voxel_grid;
    private ArrayList<Vector3f> positions = new ArrayList<Vector3f>();
    private int num_threads;

    // Constructor with no voxel grid provided
    public MultithreadedVoxelGrid(int resolution, int num_threads) {
        this.resolution = resolution;
        this.num_threads = num_threads;
        // create a sample voxel grid
        this.voxel_grid = new ArrayList<Float>();
        for (int z = 0; z < resolution; z++) {
            for (int y = 0; y < resolution; y++) {
                for (int x = 0; x < resolution; x++) {
                    voxel_grid.add(VoxelGrid.scalar_field((float)x, (float)y, (float)z));
                }
            }
        }
    }

    // Constructor with voxel grid provided
    public MultithreadedVoxelGrid(ArrayList<Float> voxel_grid, int resolution, int num_threads) {
        this.resolution = resolution;
        this.num_threads = num_threads;
        this.voxel_grid = voxel_grid;
    }

    public MultithreadedVoxelGrid(float[][][] voxel_grid, int resolution, int num_threads) {
        this.resolution = resolution;
        this.num_threads = num_threads;
        this.voxel_grid = new ArrayList<Float>();
        for (int z = 0; z < resolution; z++) {
            for (int y = 0; y < resolution; y++) {
                for (int x = 0; x < resolution; x++) {
                    this.voxel_grid.add(voxel_grid[z][y][x]);
                }
            }
        }
    }

    public ArrayList<Vector3f> create_positions() {
        // initialize threads and grid processors
        Thread[] threads = new Thread[num_threads];
        GridProcessor[] grid_processors = new GridProcessor[num_threads];
        // keep track of which thread is processing which part of the grid
        HashMap<Thread, GridProcessor> thread_to_grid_processor = new HashMap<Thread, GridProcessor>();

        // start threads
        num_rows_per_thread = this.resolution / num_threads;
        for (int i = 0; i < num_threads; i++) {
            GridProcessor grid_processor = new GridProcessor(voxel_grid, resolution, num_rows_per_thread * i, num_rows_per_thread);
            grid_processors[i] = grid_processor;
            Thread object = new Thread(grid_processor);
            threads[i] = object;
            thread_to_grid_processor.put(object, grid_processor);
            object.start();
        }

        // wrap up threads
        for (Thread thread : threads) {
            try {
                thread.join(); // wait for each thread to finish
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                // display each thread's positions
                GridProcessor grid_processor = thread_to_grid_processor.get(thread);
                // merge in thread's positions to main positions
                positions.addAll(grid_processor.get_positions());
            }
        }

        return this.positions;
    }

    public static void main(String[] args) {
        int resolution = 64;
        int num_threads = 32;
        if (args.length == 2) {
            String input = args[0];
            resolution = Integer.parseInt(input);
            String input2 = args[1];
            num_threads = Integer.parseInt(input2);
        }

        // Create Worley Noise from the Worley3DThreaded file
        Worley3DThreaded worley = new Worley3DThreaded(resolution, resolution, resolution, 8);
        worley.invert();
        float[][][] worley_noise = worley.getData();

        // for (int z = 0; z < resolution; z++) {
        //     for (int y = 0; y < resolution; y++) {
        //         for (int x = 0; x < resolution; x++) {
        //             System.out.print(worley_noise[z][y][x]);
        //         }
        //     }
        //     System.out.println("");
        // }


        // MultithreadedVoxelGrid example = new MultithreadedVoxelGrid(resolution, num_threads);
        MultithreadedVoxelGrid example = new MultithreadedVoxelGrid(worley_noise, resolution, num_threads);

        long start = System.nanoTime();

        example.create_positions();

        long end = System.nanoTime();

        System.out.println("Number of vertices: " + example.positions.size());
        System.out.println("Time (s): " + (end - start) / 1000000000.0 + "s");
    }
}